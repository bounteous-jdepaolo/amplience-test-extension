<!DOCTYPE html>
<html>
<body>
<script src="https://unpkg.com/dc-extensions-sdk/dist/dc-extensions-sdk.umd.js"></script>

<div>
  <p class="areWeInSync">HTML generated: <span class="yesOrNo"></span></p>
</div>

<script>

    class Extension {
      constructor(sdk) {

        this.sdk = sdk;

        //Getting Extension paramaters (with defaults)
        const {
          prefix = "https://c1.adis.ws/v1/content/bounteous/content-item/",
          template = "acc-template-static-landing-page",
          locale = ",en-*,*"
        } = this.sdk.params.instance;

        this.currentValue = "";
        //can be used to diaplay if the HTNK is updated / stored or not. Or maybe a buttton like "Generate HTML" :/ ?
        this.syncVisual = document.querySelector(".areWeInSync .yesOrNo");

        this.setCurrentValue()
        .then(() => { 
          //Get the deliveryId of teh current page contentType
          this.assignCurrentDeliveryId()
          .then(deliveryId => {
            //Call teh Delivery API to get the rendered HTML content
            this.getRawHtmlFromDeliveryAPI(prefix, deliveryId, template, locale)
            .then(data => {
                //Assign HTML generated value
                this.updateFieldValue(data);
            });
          })
        })
        .finally(() => {
          //Hiding the frame for now. 
          //This will basically always force updating the rendered hHTML field
          //It will also force the "save" button to be active all the time as a side effect
          // Another side effect for now is that it will not display generic errors (i.e Extension init )
          this.sdk.frame.stopAutoResizer();
          this.sdk.frame.setHeight(0);
        })
      }

      async updateFieldValue(value) {
        try {
          await this.sdk.field.setValue(value);
          console.log('updated the field value with:');
          console.log(value);
        } catch (err) {
          //The field value is not set to the new value, write a warning on the console
          console.log(err.message);
        }
      }

      async setCurrentValue() {
        try {
          const savedValue = await this.sdk.field.getValue();
          if (typeof savedValue !== "undefined") {
            console.log('got savedValue (this.sdk.field.getValue):');
            console.log(savedValue);
            //do nothing but keep track of current value
            this.currentValue = savedValue;
          }
        } catch (err) {
          console.log(err);
        }
      }

      async assignCurrentDeliveryId(){
        try {
          let contentItem = await this.sdk.contentItem.getCurrent();
          if (typeof contentItem !== "undefined") {
            console.log('got content item (contains deliveryId):');
            console.log(contentItem);
            return contentItem.deliveryId;
          }
        } catch (err) {
          console.log(err)
        }
      }

      async getRawHtmlFromDeliveryAPI(prefix, deliveryId, template, locale) 
      {
        console.log("fetch URL", `${prefix}${deliveryId}?template=${template}&locale=${locale}`);
        //TODO: consolidate fetching errors with better Promise handling
        let response = await (await (fetch(`${prefix}${deliveryId}?template=${template}&locale=${locale}`)
          .then(data => {
            console.log('got response back from fetch...');//REMOVE
            console.log(data);//REMOVE
            console.log(data.text());
            return data.text()
          })
          .catch(err => {
            console.log('Error: ', err)
          })
        ))
        return response
      }
    }


(async function  () {
    try {
      new Extension(await dcExtensionsSdk.init())
    } catch (e) {
      document.body.innerHTML = 'Failed to initialize the Extension'
    }
})()


  </script>

  </body>

</html>
